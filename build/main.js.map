{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.3.0\n */\n\nimport * as utils from '@iobroker/adapter-core';\nimport ModbusRTU from 'modbus-serial';\nimport * as protocoll from '/home/pi/ioBroker.wr-goodwe-mt/src/protocol.json';\n\nclass WrGoodweMt extends utils.Adapter {\n    private client = new ModbusRTU();\n    private ids: number[] = [];\n\n    private sleep = (ms:any) => new Promise(resolve => setTimeout(resolve, ms));\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'wr-goodwe-mt',\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('stateChange', this.onStateChange.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n    }\n\n    private async onReady(): Promise<void> {\n        this.ids = new Array(this.config.endID-this.config.startID+1);\n        this.log.debug(\"Start ID:\" + String(this.config.startID));\n        this.log.debug(\"End ID:\" + String(this.config.endID));\n        this.setState('info.connection', false, true);\n\n        for(let i =this.config.startID; i <=this.config.endID; i++){\n            this.ids[i-this.config.startID] = i;\n\n\n            await this.setObjectNotExistsAsync('WR'+i, {\n                type: 'channel',\n                common: {\n                    name: 'WR'+i,\n                },\n                native: {},\n            });\n        }\n\n        this.client.connectRTUBuffered(this.config.Interface, { baudRate: 9600 , parity: 'none', dataBits: 8, stopBits: 1, });\n        await this.startComm();\n        await this.client.setTimeout(1000);\n    }\n\n    private async read(register: number):Promise<number>{\n        try{\n            const val =  await this.client.readHoldingRegisters(register, 1);\n            const bu = Buffer.from([val.buffer[0],val.buffer[1]]);\n            return bu.readInt16BE(0);\n        }\n        catch(e: any){\n            this.log.error(String(e.message));\n            return -1;\n        }\n    }\n\n    private async startComm():Promise<void>{\n        const metersIdList = this.ids;\n        const getMeterValue = async (id:number) => {\n\n            for(let i = 0; i < protocoll.Read.Adresses.length; i++){\n                this.log.debug('WR'+id+'.'+protocoll.Read.Adresses[i].Name);\n\n                await this.setObjectNotExistsAsync('WR'+id+'.'+protocoll.Read.Adresses[i].Name, {\n                    type: 'state',\n                    common: {\n                        name: protocoll.Read.Adresses[i].Name,\n                        type: 'number',\n                        role: 'indicator',\n                        read: true,\n                        unit: protocoll.Read.Adresses[i].Unit,\n                        write: true,\n                    },\n                    native: {},\n                });\n                await this.client.setID(id);\n                const val = await this.read(protocoll.Read.Adresses[i].Register[0]);\n                await this.setState('WR'+id+'.'+protocoll.Read.Adresses[i].Name, val*protocoll.Read.Adresses[i].Factor);\n            }\n            return 1;\n        }\n\n        const getMetersValue = async (meters:any) => {\n            try{\n                if(this.client.isOpen){\n                    this.setState('info.connection', true, true);\n                }\n                else{\n                    this.setState('info.connection', false, true);\n                }\n                for(const meter of meters) {\n                    await getMeterValue(meter);\n                    await this.sleep(100);\n                }\n            } catch(e: any){\n            } finally {\n                setImmediate(() => {\n                    getMetersValue(metersIdList);\n                })\n            }\n        }\n        getMetersValue(metersIdList);\n    }\n\n    private async onUnload(callback: () => void): Promise<void> {\n        try {\n            this.log.debug('vor schlie\u00DFen:'+String(this.client.isOpen))\n            await this.client.close(callback);\n            this.log.debug('nach schlie\u00DFen:'+String(this.client.isOpen))\n            callback();\n        } catch (e) {\n            callback();\n        }\n    }\n\n\n    private onStateChange(id: string, state: ioBroker.State | null | undefined): void {\n        if (state) {\n            this.log.info(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n        } else {\n            this.log.info(`state ${id} deleted`);\n        }\n    }\n}\n\nif (require.main !== module) {\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new WrGoodweMt(options);\n} else {\n    (() => new WrGoodweMt())();\n}"],
  "mappings": "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",
  "names": ["ModbusRTU"]
}
